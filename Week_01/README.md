#一、数组
##1. 数组如何实现随机访问
####1） 数组是一种线性数据结构，用连续的存储空间存储相同类型数据
####I） 线性表：数组、链表、队列、栈 非线性表：树 图
####II） 连续的内存空间、相同的数据，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作
####a) 数组如何实现下标随机访问。
引入数组再内存中的分配图，得出寻址公式
####b) 纠正数组和链表的错误认识。数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。
正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O（1）
##2. 低效的插入和删除
####1） 插入：从最好O(1) 最坏O(n) 平均O(n)
####2） 插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把心的元素，插入到第k个位置，此处复杂度为O(1)。
####3） 删除：从最好O(1) 最坏O(n) 平均O(n)
####4） 多次删除集中在一起，提高删除效率
记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。
##3. 警惕数组的访问越界问题
用C语言循环越界访问的例子说明访问越界的bug。此例在《C陷阱与缺陷》出现过，很惭愧，看过但是现在也只有一丢丢印象。翻了下书，替作者加上一句话：如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。
##4. 容器能否完全替代数组
相比于数字，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过存储容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。
数组适合的场景：
####1） Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别关注性能，可以考虑数组
####2） 若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组
####3） 表示多维数组时，数组往往更加直观。
####4） 业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。

#二、链表
##1、什么是链表？
####1).和数组一样，链表也是一种线性表。
####2).从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。
####3).链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。
##2、为什么使用链表？即链表的特点
####1).插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。
####2).和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。
##3、常用链表：单链表、循环链表和双向链表
####1).单链表
#####a）每个节点只包含一个指针，即后继指针。
#####b）单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。
#####c）性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。
####2).循环链表
#####a）除了尾节点的后继指针指向首节点的地址外均与单链表一致。
#####b）适用于存储有循环特点的数据，比如约瑟夫问题。
####3).双向链表
#####a）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。
#####b）首节点的前驱指针prev和尾节点的后继指针均指向空地址。
#####c）性能特点：
和单链表相比，存储相同的数据，需要消耗更多的存储空间。
插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p->next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。
对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。
####4).双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。
##4、选择数组还是链表？
####1).插入、删除和随机访问的时间复杂度
数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。
链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。
####2).数组缺点
#####a）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。
#####b）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。
####3).链表缺点
#####a）内存空间消耗更大，因为需要额外的空间存储指针信息。
#####b）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。
####4).如何选择？
数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。
如果代码对内存的使用非常苛刻，那数组就更适合。

#栈
##1、什么是栈
####1).后进者先出，先进者后出，这就是典型的“栈”结构。
####2).从栈的操作特性来看，是一种“操作受限”的线性表，只允许在端插入和删除数据。
##2、为什么需要栈？
####1).栈是一种操作受限的数据结构，其操作特性用数组和链表均可实现。
####2).但，任何数据结构都是对特定应用场景的抽象，数组和链表虽然使用起来更加灵活，但却暴露了几乎所有的操作，难免会引发错误操作的风险。
####3).所以，当某个数据集合只涉及在某端插入和删除数据，且满足后进者先出，先进者后出的操作特性时，我们应该首选栈这种数据结构。
##3、如何实现栈？
####1).栈的API
```
public class Stack<Item> {
//压栈
public void push(Item item){}
//弹栈
public Item pop(){}
//是否为空
public boolean isEmpty(){}
//栈中数据的数量
public int size(){}
//返回栈中最近添加的元素而不删除它
public Item peek(){}
}
```
####2).数组实现（自动扩容）
时间复杂度分析：根据均摊复杂度的定义，可以得数组实现（自动扩容）符合大多数情况是O(1)级别复杂度，个别情况是O(n)级别复杂度，比如自动扩容时，会进行完整数据的拷贝。
空间复杂度分析：在入栈和出栈的过程中，只需要一两个临时变量存储空间，所以O(1)级别。我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。
####3).链表实现
时间复杂度分析：压栈和弹栈的时间复杂度均为O(1)级别，因为只需更改单个节点的索引即可。
空间复杂度分析：在入栈和出栈的过程中，只需要一两个临时变量存储空间，所以O(1)级别。我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。